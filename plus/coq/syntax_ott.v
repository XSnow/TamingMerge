(* generated by Ott 0.30, locally-nameless lngen from: ../ott/rules.ott *)
Require Import Metalib.Metatheory.
(** syntax *)
Definition i : Set := nat.

Inductive typ : Set :=  (*r types *)
 | t_int : typ (*r int *)
 | t_top : typ (*r top *)
 | t_arrow (A:typ) (B:typ) (*r function types *)
 | t_and (A:typ) (B:typ) (*r intersection *)
 | t_rcd (l:i) (A:typ) (*r record *).

Inductive exp : Set :=  (*r expressions *)
 | e_var_b (_:nat) (*r variables *)
 | e_var_f (x:var) (*r variables *)
 | e_top : exp (*r top *)
 | e_lit (i5:i) (*r lit *)
 | e_abs (A:typ) (e:exp) (B:typ) (*r abstractions *)
 | e_fixpoint (e:exp) (A:typ) (*r fixpoint *)
 | e_app (e1:exp) (e2:exp) (*r applications *)
 | e_merge (e1:exp) (e2:exp) (*r merge *)
 | e_anno (e:exp) (A:typ) (*r annotation *)
 | e_rcd (l:i) (e:exp) (*r record *)
 | e_proj (e:exp) (l:i) (*r projection *).

Inductive st : Set :=  (*r input type or projection label *)
 | st_ty (A:typ)
 | st_la (l:i).

Definition ctx : Set := list ( atom * typ ).

Inductive dirflag : Set :=  (*r checking direction *)
 | Inf : dirflag
 | Chk : dirflag.

Inductive vl : Set :=  (*r value or projection label *)
 | vl_exp (v:exp)
 | vl_la (l:i).

Definition ls : Set := list st.

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_exp_wrt_exp_rec (k:nat) (e_5:exp) (e__6:exp) {struct e__6}: exp :=
  match e__6 with
  | (e_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => e_var_b nat
        | inleft (right _) => e_5
        | inright _ => e_var_b (nat - 1)
      end
  | (e_var_f x) => e_var_f x
  | e_top => e_top 
  | (e_lit i5) => e_lit i5
  | (e_abs A e B) => e_abs A (open_exp_wrt_exp_rec (S k) e_5 e) B
  | (e_fixpoint e A) => e_fixpoint (open_exp_wrt_exp_rec (S k) e_5 e) A
  | (e_app e1 e2) => e_app (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
  | (e_merge e1 e2) => e_merge (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
  | (e_anno e A) => e_anno (open_exp_wrt_exp_rec k e_5 e) A
  | (e_rcd l e) => e_rcd l (open_exp_wrt_exp_rec k e_5 e)
  | (e_proj e l) => e_proj (open_exp_wrt_exp_rec k e_5 e) l
end.

Definition open_vl_wrt_exp_rec (k:nat) (e5:exp) (vl5:vl) : vl :=
  match vl5 with
  | (vl_exp v) => vl_exp (open_exp_wrt_exp_rec k e5 v)
  | (vl_la l) => vl_la l
end.

Definition open_vl_wrt_exp e5 vl5 := open_vl_wrt_exp_rec 0 vl5 e5.

Definition open_exp_wrt_exp e_5 e__6 := open_exp_wrt_exp_rec 0 e__6 e_5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_exp *)
Inductive lc_exp : exp -> Prop :=    (* defn lc_exp *)
 | lc_e_var_f : forall (x:var),
     (lc_exp (e_var_f x))
 | lc_e_top : 
     (lc_exp e_top)
 | lc_e_lit : forall (i5:i),
     (lc_exp (e_lit i5))
 | lc_e_abs : forall (A:typ) (e:exp) (B:typ),
      ( forall x , lc_exp  ( open_exp_wrt_exp e (e_var_f x) )  )  ->
     (lc_exp (e_abs A e B))
 | lc_e_fixpoint : forall (e:exp) (A:typ),
      ( forall x , lc_exp  ( open_exp_wrt_exp e (e_var_f x) )  )  ->
     (lc_exp (e_fixpoint e A))
 | lc_e_app : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (e_app e1 e2))
 | lc_e_merge : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (e_merge e1 e2))
 | lc_e_anno : forall (e:exp) (A:typ),
     (lc_exp e) ->
     (lc_exp (e_anno e A))
 | lc_e_rcd : forall (l:i) (e:exp),
     (lc_exp e) ->
     (lc_exp (e_rcd l e))
 | lc_e_proj : forall (e:exp) (l:i),
     (lc_exp e) ->
     (lc_exp (e_proj e l)).

(* defns LC_vl *)
Inductive lc_vl : vl -> Prop :=    (* defn lc_vl *)
 | lc_vl_exp : forall (v:exp),
     (lc_exp v) ->
     (lc_vl (vl_exp v))
 | lc_vl_la : forall (l:i),
     (lc_vl (vl_la l)).
(** free variables *)
Fixpoint fv_exp (e_5:exp) : vars :=
  match e_5 with
  | (e_var_b nat) => {}
  | (e_var_f x) => {{x}}
  | e_top => {}
  | (e_lit i5) => {}
  | (e_abs A e B) => (fv_exp e)
  | (e_fixpoint e A) => (fv_exp e)
  | (e_app e1 e2) => (fv_exp e1) \u (fv_exp e2)
  | (e_merge e1 e2) => (fv_exp e1) \u (fv_exp e2)
  | (e_anno e A) => (fv_exp e)
  | (e_rcd l e) => (fv_exp e)
  | (e_proj e l) => (fv_exp e)
end.

Definition fv_vl (vl5:vl) : vars :=
  match vl5 with
  | (vl_exp v) => (fv_exp v)
  | (vl_la l) => {}
end.

(** substitutions *)
Fixpoint subst_exp (e_5:exp) (x5:var) (e__6:exp) {struct e__6} : exp :=
  match e__6 with
  | (e_var_b nat) => e_var_b nat
  | (e_var_f x) => (if eq_var x x5 then e_5 else (e_var_f x))
  | e_top => e_top 
  | (e_lit i5) => e_lit i5
  | (e_abs A e B) => e_abs A (subst_exp e_5 x5 e) B
  | (e_fixpoint e A) => e_fixpoint (subst_exp e_5 x5 e) A
  | (e_app e1 e2) => e_app (subst_exp e_5 x5 e1) (subst_exp e_5 x5 e2)
  | (e_merge e1 e2) => e_merge (subst_exp e_5 x5 e1) (subst_exp e_5 x5 e2)
  | (e_anno e A) => e_anno (subst_exp e_5 x5 e) A
  | (e_rcd l e) => e_rcd l (subst_exp e_5 x5 e)
  | (e_proj e l) => e_proj (subst_exp e_5 x5 e) l
end.

Definition subst_vl (e5:exp) (x5:var) (vl5:vl) : vl :=
  match vl5 with
  | (vl_exp v) => vl_exp (subst_exp e5 x5 v)
  | (vl_la l) => vl_la l
end.


(** definitions *)

(* defns Values *)
Inductive value : exp -> Prop :=    (* defn value *)
 | value_unit : 
     value e_top
 | value_lit : forall (i5:i),
     value (e_lit i5)
 | value_anno : forall (A:typ) (e:exp) (B:typ),
     lc_exp (e_abs A e B) ->
     value (e_abs A e B)
 | value_merge : forall (v1 v2:exp),
     value v1 ->
     value v2 ->
     value (e_merge v1 v2)
 | value_rcd : forall (l:i) (v:exp),
     value v ->
     value (e_rcd l v).

(* defns TopLikeType *)
Inductive topLike : typ -> Prop :=    (* defn topLike *)
 | TL_top : 
     topLike t_top
 | TL_and : forall (A B:typ),
     topLike A ->
     topLike B ->
     topLike (t_and A B)
 | TL_arr : forall (A B:typ),
     topLike B ->
     topLike (t_arrow A B)
 | TL_rcd : forall (l:i) (B:typ),
     topLike B ->
     topLike (t_rcd l B).

(* defns SplitType *)
Inductive spl : typ -> typ -> typ -> Prop :=    (* defn spl *)
 | Sp_and : forall (A B:typ),
     spl  (t_and A B)   A   B 
 | Sp_arrow : forall (A B C D:typ),
     spl B C D ->
     spl  (t_arrow A B)   (t_arrow A C)   (t_arrow A D) 
 | Sp_rcd : forall (l:i) (B C D:typ),
     spl B C D ->
     spl (t_rcd l B) (t_rcd l C) (t_rcd l D).

(* defns OrdinaryType *)
Inductive ord : typ -> Prop :=    (* defn ord *)
 | O_top : 
     ord t_top
 | O_int : 
     ord t_int
 | O_arrow : forall (A B:typ),
     ord B ->
     ord (t_arrow A B)
 | O_rcd : forall (l:i) (B:typ),
     ord B ->
     ord (t_rcd l B).

(* defns TopLikeR *)
Inductive topLikeR : typ -> Prop :=    (* defn topLikeR *)
 | TLR_top : 
     topLikeR t_top
 | TLR_and : forall (C A B:typ),
     spl C A B ->
     topLikeR A ->
     topLikeR B ->
     topLikeR C
 | TLR_arr : forall (A B:typ),
     ord B ->
     topLikeR B ->
     topLikeR (t_arrow A B)
 | TLR_rcd : forall (l:i) (B:typ),
     ord B ->
     topLikeR B ->
     topLikeR (t_rcd l B).

(* defns Disjoint *)
Inductive disjoint : typ -> typ -> Prop :=    (* defn disjoint *)
 | D_topL : forall (A:typ),
     disjoint t_top A
 | D_topR : forall (A:typ),
     disjoint A t_top
 | D_andL : forall (A1 A2 B:typ),
     disjoint A1 B ->
     disjoint A2 B ->
     disjoint (t_and A1 A2) B
 | D_andR : forall (A B1 B2:typ),
     disjoint A B1 ->
     disjoint A B2 ->
     disjoint A (t_and B1 B2)
 | D_IntArr : forall (A1 A2:typ),
     disjoint t_int (t_arrow A1 A2)
 | D_ArrInt : forall (A1 A2:typ),
     disjoint (t_arrow A1 A2) t_int
 | D_ArrArr : forall (A1 A2 B1 B2:typ),
     disjoint A2 B2 ->
     disjoint (t_arrow A1 A2) (t_arrow B1 B2)
 | D_rcdEq : forall (l:i) (A B:typ),
     disjoint A B ->
     disjoint (t_rcd l A) (t_rcd l B)
 | D_rcdNeq : forall (l1:i) (A:typ) (l2:i) (B:typ),
      l1  <>  l2  ->
     disjoint (t_rcd l1 A) (t_rcd l2 B)
 | D_IntRcd : forall (l:i) (A:typ),
     disjoint t_int (t_rcd l A)
 | D_RcdInt : forall (l:i) (A:typ),
     disjoint (t_rcd l A) t_int
 | D_ArrRcd : forall (A1 A2:typ) (l:i) (A:typ),
     disjoint (t_arrow A1 A2) (t_rcd l A)
 | D_RcdArr : forall (l:i) (A A1 A2:typ),
     disjoint (t_rcd l A) (t_arrow A1 A2).

(* defns OSubtyping *)
Inductive osub : typ -> typ -> Prop :=    (* defn osub *)
 | OS_refl : forall (A:typ),
     osub A A
 | OS_trans : forall (A C B:typ),
     osub A B ->
     osub B C ->
     osub A C
 | OS_top : forall (A:typ),
     osub A t_top
 | OS_topArr : 
     osub t_top (t_arrow t_top t_top)
 | OS_topRcd : forall (l:i),
     osub t_top (t_rcd l t_top)
 | OS_arr : forall (A C B D:typ),
     osub B A ->
     osub C D ->
     osub (t_arrow A C) (t_arrow B D)
 | OS_and : forall (A B C:typ),
     osub A B ->
     osub A C ->
     osub A (t_and B C)
 | OS_andl : forall (A B:typ),
     osub (t_and A B) A
 | OS_andr : forall (A B:typ),
     osub (t_and A B) B
 | OS_distArr : forall (A B C:typ),
     osub (t_and  (t_arrow A B)   (t_arrow A C) ) (t_arrow A (t_and B C))
 | OS_rcd : forall (l:i) (A B:typ),
     osub A B ->
     osub (t_rcd l A) (t_rcd l B)
 | OS_distRcd : forall (l:i) (A B:typ),
     osub (t_and (t_rcd l A) (t_rcd l B)) (t_rcd l (t_and A B)).

(* defns Subtyping *)
Inductive sub : typ -> typ -> Prop :=    (* defn sub *)
 | S_int : 
     sub t_int t_int
 | S_top : forall (A B:typ),
     ord B ->
     topLike B ->
     sub A B
 | S_andl : forall (A B C:typ),
     ord C ->
     sub A C ->
     sub (t_and A B) C
 | S_andr : forall (A B C:typ),
     ord C ->
     sub B C ->
     sub (t_and A B) C
 | S_arr : forall (A C B D:typ),
     ord D ->
     sub B A ->
     sub C D ->
     sub (t_arrow A C) (t_arrow B D)
 | S_rcd : forall (l:i) (C D:typ),
     ord D ->
     sub C D ->
     sub (t_rcd l C) (t_rcd l D)
 | S_and : forall (A D B C:typ),
     spl D B C ->
     sub A B ->
     sub A C ->
     sub A D.

(* defns DecSubtyping *)
Inductive dsub : typ -> typ -> Prop :=    (* defn dsub *)
 | DS_int : 
     dsub t_int t_int
 | DS_top : forall (A B:typ),
     topLike B ->
     dsub A B
 | DS_andl : forall (A B C:typ),
     dsub A C ->
     dsub (t_and A B) C
 | DS_andr : forall (A B C:typ),
     dsub B C ->
     dsub (t_and A B) C
 | DS_arr : forall (A C B D:typ),
     dsub B A ->
     dsub C D ->
     dsub (t_arrow A C) (t_arrow B D)
 | DS_rcd : forall (l:i) (C D:typ),
     dsub C D ->
     dsub (t_rcd l C) (t_rcd l D)
 | DS_and : forall (A D B C:typ),
     spl D B C ->
     dsub A B ->
     dsub A C ->
     dsub A D.

(* defns SubSubtyping *)
Inductive subsub : typ -> typ -> Prop :=    (* defn subsub *)
 | SubSub_z : forall (A:typ),
     subsub A A
 | SubSub_arr : forall (A1 A2 B1 B2:typ),
     sub B1 A1 ->
     subsub A2 B2 ->
     subsub (t_arrow A1 A2) (t_arrow B1 B2)
 | SubSub_rcd : forall (l:i) (A B:typ),
     subsub A B ->
     subsub (t_rcd l A) (t_rcd l B)
 | SubSub_top : forall (A:typ),
     ord A ->
     topLike A ->
     subsub t_top A
 | SubSub_split : forall (A B A1 A2 B1 B2:typ),
     spl A A1 A2 ->
     spl B B1 B2 ->
     subsub A1 B1 ->
     subsub A2 B2 ->
     subsub A B.

(* defns ConvertToArrowType *)
Inductive arrTyp : typ -> typ -> Prop :=    (* defn arrTyp *)
 | AT_arr : forall (A B:typ),
     arrTyp (t_arrow A B) (t_arrow A B)
 | AT_topArr : 
     arrTyp t_top (t_arrow t_top t_top)
 | AT_andArr : forall (A B A1 B1 A2 B2:typ),
     arrTyp A (t_arrow A1 A2) ->
     arrTyp B (t_arrow B1 B2) ->
     arrTyp (t_and A B) (t_arrow (t_and A1 B1) (t_and A2 B2))
 | AT_rcd : forall (l:i) (A:typ),
     arrTyp (t_rcd l A) (t_rcd l A)
 | AT_topRcd : forall (l:i),
     arrTyp t_top (t_rcd l t_top)
 | AT_andRcd : forall (A B:typ) (l:i) (A2 B2:typ),
     arrTyp A (t_rcd l A2) ->
     arrTyp B (t_rcd l B2) ->
     arrTyp (t_and A B) (t_rcd l (t_and A2 B2)).

(* defns Semantics *)
Inductive TypedReduce : exp -> typ -> exp -> Prop :=    (* defn TypedReduce *)
 | TReduce_refl : forall (i5:i),
     TypedReduce (e_lit i5) t_int (e_lit i5)
 | TReduce_top : forall (v:exp) (A:typ),
     lc_exp v ->
     ord A ->
     topLike A ->
     TypedReduce v A e_top
 | TReduce_arrow : forall (A:typ) (e:exp) (B C D:typ),
     lc_exp (e_abs A e B) ->
     ord D ->
      not ( topLike D )  ->
     sub C A ->
     sub B D ->
     TypedReduce (e_abs A e B)  (t_arrow C D)  (e_abs A e D)
 | TReduce_rcd : forall (l:i) (v:exp) (A:typ) (v':exp),
     ord A ->
      not ( topLike A )  ->
     TypedReduce v A v' ->
     TypedReduce (e_rcd l v) (t_rcd l A) (e_rcd l v')
 | TReduce_mergevl : forall (v1 v2:exp) (A:typ) (v1':exp),
     lc_exp v2 ->
     ord A ->
     TypedReduce v1 A v1' ->
     TypedReduce (e_merge v1 v2) A v1'
 | TReduce_mergevr : forall (v1 v2:exp) (A:typ) (v2':exp),
     lc_exp v1 ->
     ord A ->
     TypedReduce v2 A v2' ->
     TypedReduce (e_merge v1 v2) A v2'
 | TReduce_and : forall (v:exp) (A:typ) (v1 v2:exp) (B C:typ),
     spl A B C ->
     TypedReduce v B v1 ->
     TypedReduce v C v2 ->
     TypedReduce v A (e_merge v1 v2)
with papp : exp -> vl -> exp -> Prop :=    (* defn papp *)
 | Papp_abs : forall (A:typ) (e:exp) (B:typ) (v v':exp),
     lc_exp (e_abs A e B) ->
     TypedReduce v A v' ->
     papp (e_abs A e B) (vl_exp v) (e_anno  (  (open_exp_wrt_exp  e v' )  )  B)
 | Papp_proj : forall (l:i) (v:exp),
     lc_exp v ->
     papp (e_rcd l v) (vl_la l) v
 | Papp_top : forall (vl5:vl),
     lc_vl vl5 ->
     papp e_top vl5 e_top
 | Papp_merge : forall (v1 v2:exp) (vl5:vl) (e1 e2:exp),
     papp v1 vl5 e1 ->
     papp v2 vl5 e2 ->
     papp (e_merge v1 v2) vl5 (e_merge e1 e2)
with step : exp -> exp -> Prop :=    (* defn step *)
 | Step_papp : forall (v1 v2 e:exp),
     value v1 ->
     value v2 ->
     papp v1 (vl_exp v2) e ->
     step (e_app v1 v2) e
 | Step_pproj : forall (v:exp) (l:i) (v':exp),
     value v ->
     papp v (vl_la l) v' ->
     step (e_proj v l) v'
 | Step_annov : forall (v:exp) (A:typ) (v':exp),
     value v ->
     TypedReduce v A v' ->
     step (e_anno v A) v'
 | Step_appl : forall (e1 e2 e1':exp),
     lc_exp e2 ->
     step e1 e1' ->
     step (e_app e1 e2) (e_app e1' e2)
 | Step_appr : forall (v1 e2 e2':exp),
     value v1 ->
     step e2 e2' ->
     step (e_app v1 e2) (e_app v1 e2')
 | Step_merge : forall (e1 e2 e1' e2':exp),
     step e1 e1' ->
     step e2 e2' ->
     step (e_merge e1 e2) (e_merge e1' e2')
 | Step_mergel : forall (e1 v2 e1':exp),
     value v2 ->
     step e1 e1' ->
     step (e_merge e1 v2) (e_merge e1' v2)
 | Step_merger : forall (v1 e2 e2':exp),
     value v1 ->
     step e2 e2' ->
     step (e_merge v1 e2) (e_merge v1 e2')
 | Step_anno : forall (e:exp) (A:typ) (e':exp),
     step e e' ->
     step (e_anno e A) (e_anno e' A)
 | Step_fix : forall (e:exp) (A:typ),
     lc_exp (e_fixpoint e A) ->
     step (e_fixpoint e A) (e_anno  (open_exp_wrt_exp  e (e_fixpoint e A) )  A)
 | Step_rcd : forall (l:i) (e e':exp),
     step e e' ->
     step (e_rcd l e) (e_rcd l e')
 | Step_proj : forall (e:exp) (l:i) (e':exp),
     step e e' ->
     step (e_proj e l) (e_proj e' l).

(* defns PreValues *)
Inductive prevalue : exp -> Prop :=    (* defn prevalue *)
 | PV_val : forall (v:exp),
     value v ->
     prevalue v
 | PV_anno : forall (e:exp) (A:typ),
     lc_exp e ->
     prevalue (e_anno e A)
 | PV_rcd : forall (l:i) (u:exp),
     prevalue u ->
     prevalue (e_rcd l u)
 | PV_merge : forall (u1 u2:exp),
     prevalue u1 ->
     prevalue u2 ->
     prevalue (e_merge u1 u2).

(* defns PrincipalType *)
Inductive pType : exp -> typ -> Prop :=    (* defn pType *)
 | PT_top : 
     pType e_top t_top
 | PT_int : forall (i5:i),
     pType (e_lit i5) t_int
 | PT_lam : forall (A:typ) (e:exp) (B:typ),
     lc_exp (e_abs A e B) ->
     pType  ( (e_abs A e B) )   (t_arrow A B) 
 | PT_rcd : forall (l:i) (u:exp) (A:typ),
     pType u A ->
     pType (e_rcd l u) (t_rcd l A)
 | PT_anno : forall (e:exp) (A:typ),
     lc_exp e ->
     pType  ( (e_anno e A) )  A
 | PT_merge : forall (u1 u2:exp) (A B:typ),
     pType u1 A ->
     pType u2 B ->
     pType  ( (e_merge u1 u2) )   (t_and A B) .

(* defns Consistent *)
Inductive consistent : exp -> exp -> Prop :=    (* defn consistent *)
 | C_lit : forall (i5:i),
     consistent (e_lit i5) (e_lit i5)
 | C_abs : forall (A:typ) (e:exp) (B1 B2:typ),
     lc_exp (e_abs A e B1) ->
     consistent (e_abs A e B1) (e_abs A e B2)
 | C_anno : forall (e:exp) (A B:typ),
     lc_exp e ->
     consistent (e_anno e A) (e_anno e B)
 | C_rcd : forall (l:i) (u1 u2:exp),
     consistent u1 u2 ->
     consistent (e_rcd l u1) (e_rcd l u2)
 | C_disjoint : forall (u1 u2:exp) (A B:typ),
     pType u1 A ->
     pType u2 B ->
     disjoint A B ->
     prevalue u1 ->
     prevalue u2 ->
     consistent u1 u2
 | C_mergel : forall (u1 u2 u:exp),
     consistent u1 u ->
     consistent u2 u ->
     consistent (e_merge u1 u2) u
 | C_merger : forall (u u1 u2:exp),
     consistent u u1 ->
     consistent u u2 ->
     consistent u (e_merge u1 u2).

(* defns BidirectionalTyping *)
Inductive Typing : ctx -> exp -> dirflag -> typ -> Prop :=    (* defn Typing *)
 | Typ_top : forall (G:ctx),
      uniq  G  ->
     Typing G e_top Inf t_top
 | Typ_lit : forall (G:ctx) (i5:i),
      uniq  G  ->
     Typing G (e_lit i5) Inf t_int
 | Typ_var : forall (G:ctx) (x:var) (A:typ),
      uniq  G  ->
      binds  x A G  ->
     Typing G (e_var_f x) Inf A
 | Typ_abs : forall (L:vars) (G:ctx) (A:typ) (e:exp) (B:typ),
      ( forall x , x \notin  L  -> Typing  (cons ( x , A )  G )   ( open_exp_wrt_exp e (e_var_f x) )  Chk B )  ->
     Typing G (e_abs A e B) Inf (t_arrow A B)
 | Typ_app : forall (G:ctx) (e1 e2:exp) (C A B:typ),
     Typing G e1 Inf A ->
     arrTyp A (t_arrow B C) ->
     Typing G e2 Chk B ->
     Typing G (e_app e1 e2) Inf C
 | Typ_proj : forall (G:ctx) (e:exp) (l:i) (C A:typ),
     Typing G e Inf A ->
     arrTyp A (t_rcd l C) ->
     Typing G (e_proj e l) Inf C
 | Typ_rcd : forall (G:ctx) (l:i) (e:exp) (A:typ),
     Typing G e Inf A ->
     Typing G (e_rcd l e) Inf (t_rcd l A)
 | Typ_merge : forall (G:ctx) (e1 e2:exp) (A B:typ),
     Typing G e1 Inf A ->
     Typing G e2 Inf B ->
     disjoint A B ->
     Typing G (e_merge e1 e2) Inf (t_and A B)
 | Typ_anno : forall (G:ctx) (e:exp) (A:typ),
     Typing G e Chk A ->
     Typing G  ( (e_anno e A) )  Inf A
 | Typ_fix : forall (L:vars) (G:ctx) (e:exp) (A:typ),
      ( forall x , x \notin  L  -> Typing  (cons ( x , A )  G )   ( open_exp_wrt_exp e (e_var_f x) )  Chk A )  ->
     Typing G (e_fixpoint e A) Inf A
 | Typ_mergev : forall (G:ctx) (u1 u2:exp) (A B:typ),
      uniq  G  ->
     Typing  nil  u1 Inf A ->
     Typing  nil  u2 Inf B ->
     consistent u1 u2 ->
     Typing G (e_merge u1 u2) Inf (t_and A B)
 | Typ_sub : forall (G:ctx) (e:exp) (B A:typ),
     Typing G e Inf A ->
     sub A B ->
     Typing G e Chk B.


(** infrastructure *)
Hint Constructors value topLike spl ord topLikeR disjoint osub sub dsub subsub arrTyp TypedReduce papp step prevalue pType consistent Typing lc_exp lc_vl : core.


